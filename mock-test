#!/bin/bash

#
# A short demo of how to use apron.
#

. './apron'

# Enables mocking, with verbosity
APRON_enable -v

#
# define some mocks for external commands and register them
#
mock_called() {
   printf '==> MOCKED CALL: %s with %s args: %s\n' "$1" "$2" "${*:3}"
}
ls() { mock_called "$FUNCNAME" "$#" "$@"; }
df() { mock_called "$FUNCNAME" "$#" "$@"; }
cp() { mock_called "$FUNCNAME" "$#" "$@"; }
APRON_register 'cp'
APRON_register 'ls'
APRON_register 'df'

# we can even be sneaky and define a mock for a full path to a command
/bin/ls() { mock_called "$FUNCNAME" "$#" "$@"; }
APRON_register '/bin/ls'

#
# call some external commands now, notice what happens to
# the various calls.
#
ls /
cp moe larry
mv dont overwriteme
df | sed 3q

#
# pause mocking temporarily, try to run ls again
#
APRON_pause
ls /
df | sed 2q

#
# resume mocking
#
APRON_unpause
/bin/ls /

#
# Unregister a single mock, others remain
#
APRON_unregister 'ls'
ls /
df

#
# Unregister all mocks, but leave mocking enabled
#
APRON_unregister_all
df
badcommand

#
# Disable mocking, return to normal life
#
APRON_disable
df | awk 'NR == 3 { exit; } 1'
ls /
